\section{Grundlagen}
	
	\subsection{iTool3}
	
	iTool3 ist eine auf dem CakePHP 3.3 - Framework basierende eCommerce Software Lösung zur Steuerung von Produktsortimenten auf verschiedenen Marktplätzen mit dem Ziel, den
	Vertriebsprozess zu automatisieren. Es ermöglicht dem Benutzer über eine einzelne Benutzeroberfläche Produkte auf Marktplätzen wie eBay, Amazon oder einem Magento Store
	zu verwalten. Produkte können dabei händisch erstellt oder aus bestehenden Datenquellen in die Software	eingepflegt werden. Im Anschluss ist es möglich diese Produkte auf einem oder mehreren Marktplätzen anzubieten. Die Verwaltung und Abwicklung der eingehenden Bestellungen läuft dabei komplett über das iTool.
	Da für jeden Marktplatz unterschiedliche Daten benötigt werden um auf ihm erfolgreich zu verkaufen, können für jedes Produkt unterschiedliche Attribute mit wiederum unterschiedlichen Werten angelegt werden. Die Produktverwaltung der Software folgt daher dem Entity-Attribute-Value Modell.
	
	
	\subsubsection{Verkäufer und Benutzer}
	
	Es wird unterschieden zwischen Verkäufern (Core-Seller) und Benutzern (Core-User). Ein Verkäufer ist z.B. "Markisenshop 2000". Diesem Verkäufer werden Benutzer zugeordnet, die mit mehr oder weniger Rechten ausgestattet, die Produkte z.B. nur einsehen können oder Kontrolle über die gesamte Produkt- und Bestellverwaltung haben.\\
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.6\linewidth]{img/ERD_Seller_User_complete}
		\captionof{figure}[ERD]{ER-Diagramm: Verkäufer - Benutzer}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}

	 
	
	\subsubsection{Produktverwaltung}
	
	Die Produktverwaltung ist aufgeteilt in Produkte und Kategorien. \textbf{Produkte} besitzen Attribute wie Titel, Preis, Beschreibung etc. die für jeden Marktplatz auf denen diese angeboten werden sollen unterschiedlich ausfallen können. Es kann gewählt werden ob ein Produkt auf einem bestimmten Marktplatz angeboten werden soll oder nicht. Ein Produkt kann dabei mehreren \textbf{Kategorien} zugeordnet sein.\\
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.6\linewidth]{img/ERD_Category_Product}
		\captionof{figure}[ERD]{ER-Diagramm: Kategorie - Produkt}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	Eine Kind-Kategorie hat jeweils genau eine Eltern-Kategorie. Eine Eltern-Kategorie kann aber mehrere Kinder haben. Produkte sind genau einem Verkäufer zugeordnet. \\
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.6\linewidth]{img/ERD_Seller_Product}
		\captionof{figure}[ERD]{ER-Diagramm: Verkäufer - Benutzer}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	\subsubsection{Dashboard}
	
	Auf dem Dashboard werden Informationen über die Anzahl der insgesamt eingegangenen Bestellungen, den durchschnittlichen Bestellwert, die Gesamtzahl der Kunden, den insgesamt erwirtschafteten Umsatz, eine Übersicht der zuletzt eingegangenen Bestellungen sowie eine graphische Übersicht der während eines Jahres erwirtschafteten Umsätze angezeigt. 
	
	\subsection{Der BMECat}
	
	Der BMECat ist ein vom 'Bundesverband Materialwirtschaft, Einkauf und Logistik e.V' in Zusammenarbeit mit dem 'eBusiness Standardization Committee' entwickelter XML
	Standard mit dem Ziel den Austausch von Produktkatalogen zwischen Lieferanten und beschaffenden Organisationen zu standardisieren und somit zu vereinfachen.\footnote{BMECat V1.2 Spezifikation, Seite 5}. 
	
	\subsubsection{Terminologie}
	Ein \textbf{Produktkatalog} ist die Menge aller benötigten Daten, welche vom katalogerzeugenden Unternehmen an das katalogempfangende Unternehmen übermittelt werden sollen.\\
	Ein \textbf{Katalogdokument} ist eine XML-Datei, in der der Produktkatalog im BMECat-Format gespeichert und zum Katalogemfänger übermittelt wird.\\
	Eine \textbf{Kataloggruppe} ist ein Datenbereich, der eine Gruppe definiert, welcher gleichartige Artikel zugeordnet werden können. Diese wird im BMEcat-Format durch das Element \texttt{\textbf{CATALOG\_STRUCTURE}} abgebildet.\\
	Ein \textbf{Kataloggruppensystem} ist ein hierarchischer Baum von verknüpften Kataloggruppen. Es wird
	im BMEcat-Format durch das Element \texttt{\textbf{CATALOG\_GROUP\_SYSTEM}} abgebildet.\footnote{BMECat V1.2 Spezifikation, Seite 7}
	
	\subsubsection{Transaktionen}
	Im BMECat wird zwischen den 3 verschiedenen Transaktionsarten
	\begin{itemize}
	\item \texttt{\textbf{T\_NEW\_CATALOG}} - Übertragung eines neuen Produktkataloges
	\item \texttt{\textbf{T\_UPDATE\_PRODUCTS}} - Aktualisierung von Produktdaten
	\item \texttt{\textbf{T\_UPDATE\_PRICES}} - Aktualisierung von Preisinformationen
	\end{itemize} 
	unterschieden. Die Unterscheidung geschieht um die Größe eines Katalogdokumentes zu reduzieren. Es muss so z.B. nicht ein kompletter Produktkatalog übertragen werden, falls sich bei einem \(oder mehreren\) Artikel\(n\) der Preis ändert.
	
	\subsubsection{Aufbau}
	
	Ein BMECat-Dokument besteht aus einer Folge von KANN und MUSS Feldern, den dazugehörigen Datentypen und Feldlängen und ist folgendermaßen aufgebaut:
		
		\begin{enumerate}
		
			\item XML-Deklaration und Header-Bereich (mit Informationen über Kataloganbieter und Empfänger, Bezeichnung und Erstellungsdatum des Kataloges etc.  )
				\\Bsp. für einen Header:
			\begin{lstlisting}
			<HEADER>
			  <GENERATOR_INFO> Kann </GENERATOR_INFO>
			  <CATALOG> Muss </CATALOG>
			  <BUYER> Kann </BUYER>
			  <SUPPLIER> Muss </SUPPLIER>
			</HEADER>
			\end{lstlisting}
			Bsp. für XML Deklaration:
			\begin{lstlisting}
			<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE BMECAT SYSTEM "bmecat_new_catalog.dtd">
			<BMECAT version="1.2" xml:lang="de" xmlns="http://www.bmecat.org/bmecat/1.2/bmecat_new_catalog">
			\end{lstlisting}
			\item Produktgruppensystem (Baumstruktur der Produktgruppen mit den Attributwerten Root, Node und Leaf)
			\begin{lstlisting}
			<CATALOG_STRUCTURE type="root">
			   <GROUP_ID>1</GROUP_ID>
			   <GROUP_NAME>Katalog</GROUP_NAME>
			   <PARENT_ID>0</PARENT_ID>
			   <GROUP_ORDER>1</GROUP_ORDER>
			</CATALOG_STRUCTURE>
			  <CATALOG_STRUCTURE type="node">
			   <GROUP_ID>2</GROUP_ID>
			   <GROUP_NAME>Spiele &amp; Konsolen</GROUP_NAME>
			   <PARENT_ID>1</PARENT_ID>
			 </CATALOG_STRUCTURE>
			 <CATALOG_STRUCTURE type="leaf">
			   <GROUP_ID>7</GROUP_ID>
			   <GROUP_NAME>PlayStation 4</GROUP_NAME>
			   <PARENT_ID>2</PARENT_ID>
			 </CATALOG_STRUCTURE>
			\end{lstlisting}
			
			
			
			\item Artikel (mit Attributen und Werten)
			
			\begin{lstlisting}
			<ARTICLE mode="new">
				<SUPPLIER_AID>9057320097280</SUPPLIER_AID>
				<ARTICLE_DETAILS>
				   	<DESCRIPTION_SHORT>GTA 5</DESCRIPTION_SHORT>
					<DESCRIPTION_LONG>Das tolle neue Spiel</DESCRIPTION_LONG>
					<EAN>87126723434</EAN>
				... weitere Attribute ...
				</ARTICLE_DETAILS>
				...weitere Felder ...
			</ARTICLE>
			\end{lstlisting}
			
	
			\item Zuordnung der Artikel zu den Produktgruppen.
			\begin{lstlisting}
			<ARTICLE_TO_CATALOGGROUP_MAP>
				<ART_ID>9057320097280</ART_ID>
				<CATALOG_GROUP_ID>7</CATALOG_GROUP_ID>
			</ARTICLE_TO_CATALOGGROUP_MAP>
			\end{lstlisting}
		
		\end{enumerate}
		
	--- Übersicht der im BMECat verwendeten Datentypen --- noch einfügen ---
	
	Im folgenden Abschnitt wird jeder Teilbereich mit seinen Unterelementen, wie sie in vorliegender Arbeit verwandt wurden, graphisch dargestellt und kurz erläutert. Rot hervorgehoben sind jeweils die MUSS-Felder, welche zwingend in einem gültigen BMECat Dokument vorkommen müssen, grün die KANN-Felder. Ein Plus \(+\) Zeichen hinter dem Elementnamen indiziert, dass dieses Element mehrfach an dieser Stelle vorkommen kann, jedoch mindestens einmal. Ein Asterisk \(*\) zeigt an, dass dieses Element einmal, mehrfach oder nicht vorkommen kann. Das 
	
	\textbf{\underline{Header}}\\
	Im Header werden allgemeine Informationen über das Katalogdokument hinterlegt und Default Werte gesetzt. Das Element \texttt{\textbf{CATALOG}} enthält dabei Informationen zur Identifikation und Beschreibung des Produktkataloges, wie z.B. die Katalog Id, die Katalogversion oder die für das Dokument geltende Sprache sowie Elemente zum setzten von Standard-Werten wie z.B. die für das Katalogdokument geltende Währungsangabe \footnote{BMECat V 1.2 Spezifikation, Seite 27,29} 
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=1\linewidth]{img/BMECat_Header}
		\captionof{figure}[Headerstruktur]{Headerstruktur}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	
	
	\textbf{\underline{Die Transaktion T\_NEW\_CATALOG}}
	
	Diese Transaktion wird verwandt, um einen Produktkatalog neu zu übertragen. Das empfangende System reagiert dabei je nach übertragener \texttt{CATALOG\_ID}, \texttt{CATALOG\_VERSION}
	und \texttt{LANGUAGE} unterschiedlich. Dieser Zusammenhang wir später noch erläutert.
	
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.8\linewidth]{img/newCatalog}
		\captionof{figure}[T\_NEW\_CATALOG]{T\_NEW\_CATALOG}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	\textbf{\underline{Die Transaktion T\_UPDATE\_PRODUCTS}}\\
	
	Bei dieser Transaktion werden Artikeldaten übertragen und gegebenenfalls einer Kataloggruppe zugeordnet.Je nach Kennung des Artikels (s.u.)  werden die übertragenen
	Artikel im Zielsystem entweder hinzugefügt, gelöscht oder die Artikeldaten werden komplett ersetzt.
	Der Artikel wird immer komplett ausgetauscht, eine Änderung von einzelnen Datenfeldern innerhalb eines Artikels ist nicht möglich.
	Wie der Grafik entnommen werden kann ist bei dieser Transaktion nur die Übertragung von Produktdaten und die Zuordnung von Produkten zu Kataloggruppen möglich. \footnote{vgl. BMECat V 1.2 Spezifikation, Seite 52}
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.8\linewidth]{img/updateProducts}
		\captionof{figure}[T\_UPDATE\_PRODUCTS]{T\_UPDATE\_PRODUCTS}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	Das Element \texttt{T\_UPDATE\_PRODUCTS} verfügt zusätzlich über das Attribut \texttt{prev\_version}, welches die Anzahl der vorausgegangenen Updates bzw. die Nummer des übertragenen Updates enthält. 
	
	\begin{lstlisting}
	<T_UPDATE_PRODUCTS prev_version="91">...</T_UPDATE_PRODUCTS>
	\end{lstlisting}
	
	
	
	\textbf{\underline{Die Elemente CATALOG\_GROUP\_SYSTEM und CATALOG\_STRUCTURE}}\\
	
	Im Element \texttt{CATALOG\_GROUP\_SYSTEM} werden die \texttt{GROUP\_SYSTEM\_ID} und der \texttt{GROUP\_SYSTEM\_NAME} bekannt gemacht sowie die Katalogstruktur  \texttt{CATALOG\_STRUCTURE}   beschrieben. Dabei gibt es genau ein Wurzelelement, sowie beliebig viele Knoten und Blätter. Jedes Element hat dabei eine als \texttt{GROUP\_ID} bezeichnete ID und wird über \texttt{PARENT\_ID} die  dem jeweiligen Elternelement zugeordnet. Die Zuordnung der Artikel zu den Artikelgruppen erfolgt mit dem Element \texttt{ARTICLE\_TO\_CATALOG\_GROUP\_MAP} das weiter unten beschrieben wird.
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.6\linewidth]{img/catalogGroupSystem}
		\captionof{figure}[CATALOG\_GROUP\_SYSTEM und CATALOG\_STRUCTURE]{CATALOG\_GROUP\_SYSTEM und CATALOG\_STRUCTURE}
		\label{fig:header}
		\vspace{1em}
	\end{minipage} 
	
	\textbf{\underline{Das Element ARTICLE}}\\
	Das Artikelelement schließlich enthält Informationen über einen Artikel, wie Überschrift, Beschreibung, Bilder, Preisinformationen, eine \textbf{eindeutige} Artikelnummer usw. Die Artikelnummer wird über das Element \texttt{SUPPLIER\_AID} bekanntgegeben, handelt es sich um einen Variantenartikel, so bildet sich die Artikelnummer aus der \texttt{SUPPLIER\_AID} und der \texttt{SUPPLIER\_AID\_SUPPLEMENT}. Dies ist hier jedoch nicht umgesetzt. Die als \textit{eCl@ass} und \textit{Zolltarifnummer} zusammengefassten \texttt{ARTICLE\_FEATURES} werden explizit von Mercateo verlangt.
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=1\linewidth]{img/Article}
		\captionof{figure}[Article]{Article}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	Das Element \texttt{ARTICLE} verfügt über das Attribut \texttt{mode}, welches Informationen darüber enthält, ob es sich um die Anlage eines neuen Artikel, ein Update der Artikelinformationen oder die Löschung eines Artikels handelt.
	
	\begin{lstlisting}
	<ARTICLE mode="new">...</ARTICLE>
	<ARTICLE mode="update">...</ARTICLE>
	<ARTICLE mode="delete">...</ARTICLE>
	\end{lstlisting}
	
	
	
	\textbf{\underline{Das Element ARTICLE\_TO\_CATALOG\_GROUP\_MAP}}\\
	
	Um Produkte ihren Kategorien zuordnen zu können wird das Element \texttt{ARTICLE\_TO\_CATALOGGROUP\_MAP} verwandt. Es erfolgt hier eine Verknüfung aus der eindeutigen Artikelnummer und der \texttt{GROUP\_ID} welcher der Artikel zugeordnet werden soll. Eine Mehrfachzuordnung ist möglich, d.h. ein Artikel kann in unterschiedliche Kategorien "eingehängt" werden.
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.7\linewidth]{img/articleGroupMap}
		\captionof{figure}[ArticleGroupMap]{ARTICLE\_TO\_CATALOG\_GROUP\_MAP}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	Im Kontext der Transaktion \texttt{T\_UPDATE\_PRODUCTS} verfügt das Element zusätzlich über das Attribut \texttt{mode}, mit welchem angegeben wird, ob es sich um eine Neuzuweisung zu einer Kategorie handelt oder der Artikel aus einer Kategorie entfernt werden soll.
	
	\begin{lstlisting}
	<ARTICLE_TO_CATALOGGROUP_MAP mode="new">...</<ARTICLE_TO_CATALOGGROUP_MAP>
	<ARTICLE_TO_CATALOGGROUP_MAP mode="delete">...</<ARTICLE_TO_CATALOGGROUP_MAP>
	\end{lstlisting}
	
	
	\textbf{\underline{Zusammenspiel verschiedener Transaktionen}}\\
	
	Die folgende Grafik zeigt, wie das empfangende System bei der Transaktion \texttt{T\_NEW\_CATALOG} je nach übergebener \texttt{CATALOG\_ID}, \texttt{CATALOG\_VERSION} und \texttt{LANGUAGE} reagiert.
	
	\begin{minipage}{\linewidth}
		\vspace{1em}
		\centering
		\includegraphics[width=0.65\linewidth]{img/newCatalogLogik}
		\captionof{figure}[New Catalog Logik]{Flowchart T\_NEW\_CATALOG}
		\label{fig:header}
		\vspace{1em}
	\end{minipage}
	
	Kommt die Transaktion \texttt{T\_UPDATE\_PRODUCTS} zur Anwendung, gilt es folgendes zu beachten:\footnote{vgl. hierzu: BMECat V 1.2 Spezifikation, Seite 52} 
	\begin{itemize}
		\item Die übertragene \texttt{CATALOG\_ID} des jeweiligen Lieferanten und die dazugehörige\\ \texttt{CATALOG\_VERSION} müssen im Zielsystem bereits vorhanden sein.
		\item Das Attribut \texttt{prev\_version} muss bei der ersten anderen Transaktionsart nach\\ \texttt{T\_NEW\_CATALOG}, (\texttt{T\_UPDATE\_PRODUCTS},\texttt{T\_UPDATE\_PRICES}) auf '0' gesetzt werden.
		\item Danach wird es bei jeder solchen Transaktion um '1' erhöht.
	\end{itemize}
	
	
	---- Übersicht, tabellarisch oder nicht über die wichtigsten Felder und ihre Einschränkungen, vor allem die von Mercateo ----
	
	\subsection{Das Cake-PHP Framework}
	
	Cake PHP ist ein Webframework, das dem MVC (Model-View-Controller) Schema folgt und dabei die Softwaredesignparadigmen DRY (Don't repeat yourself) und 'Convention over configuration' umsetzt. 
	
	\subsubsection{Convention over Configuration in CakePHP}
	
	%Hier noch eine Erklärung zu COC von den Big Five einfügen
	In CakePHP wird das Softwaredesign-Paradigma der 'Konvention vor Konfiguration' konsequent umgesetzt.\newline 
	
	 Die Klassennamen von \textbf{Controllern} sind im Plural verfasst, 'CamelCased' und enden auf \textit{Controller}. \texttt{UsersController} und \texttt{ArticleCategoriesController} sind Beispiele dafür. Eine öffentliche Methode eines solchen Controllers kann über einen Webbrowser aufgerufen werden. Per Konvention werden URLs klein geschrieben und mit Bindestrich verbunden.
	\url{http://samplesite.com/article-categorie/view} ruft demnach die öffentliche \texttt{view()} Methode des ArticleCategoriesControllers auf.\\
	\newline
	Die Namen von \textbf{Model} Klassen sind 'CamelCased' und im Plural. Der Name der zum Model gehörenden Tabelle ist im Plural verfasst und mit einem Unterstrich verbunden.\\
	\texttt{article\_categories} ist die dem Model \texttt{ArticleCategories} zugrundeliegende Tabelle. Um einen Fremdschlüssel auf eine Tabelle zu vergeben genügt es das Suffix \texttt{\_id} an den kleingeschriebenen Namen dieser Tabelle anzuhängen. Wenn Users eine hasMany Beziehung zu Articles hat, kann mit dem Fremdschlüssel \texttt{user\_id} in der \texttt{articles}-Tabelle auf den entsprechenden Eintrag in der \texttt{users}-Tabelle verwiesen werden. \newline
	
	Die Template Datei einer \textbf{View} ist nach der entsprechenden Methode im Controller benannt die sie darstellen soll. Die \texttt{view()} Methode der \texttt{ArticlesController} Klasse würde demnach unter \texttt{src/Template/Articles/view.ctp} nach einem View-Template suchen\footnote{vgl. hierzu: \url{http://book.cakephp.org/3.0/en/intro/conventions.html}}.
	
	\subsubsection{Model}
	
	Das Backend einer CakePHP Anwendung wird von einer SQL Datenbank gebildet. Das Model repräsentiert die Daten einer Anwendung und enthält die Geschäftslogik zur Datenmanipulation. Nach der CakePHP Konvention wird die Datenbankverbindung einmal in der \texttt{config/app.php} konfiguriert. Die Model-Klasse stellt dabei Methoden zur Verfügung, über die es möglich ist, den Zustand der Daten abzufragen, die Daten zu filtern und zu verändern. Die CRUD-Funktionalität (CREATE-READ-UPDATE-DELETE) ist so direkt im Model integriert.\footnote{vgl. hierzu: Webentwicklung mit CakePHP, 2. Auflage, O'Reilly, Seite 7}. 
	Die Beziehungen einzelner Models zueinander werden über \textit{Associations} hergestellt. Die vier Assoziationstypen in CakePHP sind:\\

	
		\begin{tabularx}{\textwidth}{p{1cm} X X p{8cm}}
		\cline{2-4}
		\rowcolor[HTML]{EFEFEF} 
		 Nr. & Beziehung & Typ & Beispiel \\ \cline{1-4} \addlinespace
		1. & one to one & hasOne & Ein Museum hat eine Adresse. \\
		2. & one to many & hasMany & In einem Museum hängen mehrere Kunstwerke. \\
		3. & many to one & belongsTo & Mehrere Bilder gehören zu einem Museum. \\  
		4. & many to many & belongsToMany & Ein Student hat mehrere Professoren. Ein Professor hat mehrere Hörer. \\ \addlinespace \cline{1-4}     
		\end{tabularx}
	\\
	
	
	Es ist möglich ein \textit{Model} um ein oder mehrere \textit{Behavior} zu erweitern. Dabei handelt es sich um Klassen, in denen, ähnlich einem Trait, Funktionen zur Erweiterung des Models gekapselt sind. Ein Beispiel hierfür ist das Tree-Behavior, das es ermöglicht hierarchische Datenstrukturen in der Datenbank zu pflegen. Anwendung hierfür kann z.B. die Abbildung einer Kategoriestruktur sein \footnote{vgl. hierzu: \url{http://book.cakephp.org/3.0/en/orm/behaviors/tree.html}}.
	
	Mit Hilfe von im Model definierten Validatoren können zu speichernde Daten auf Vollständigkeit und Konsistenz geprüft werden. 
	
	 Später bei der Beschreibung des Codes auf eigenen Validator verweisen. (MercateoAccountsTable::validateCatalogVersionFormat)
	\lstset{language=PHP}
	\begin{lstlisting}

	$validator
     	->requirePresence('catalog_name', 'create')
     	->notEmpty('catalog_name')
     	->add('catalog_name', [
	         'maxLength' => [
	             'rule' => ['maxLength', 100],
	             'message' => 'maxLength = 100.'
	         ]
     ]);
	
	\end{lstlisting}
	
	\subsubsection{View}
	
	Die View ist für die Darstellung der Daten in der Anwendung zuständig. Eine View ist in CakePHP immer auf ein bestimmtes Model bezogen und wird nicht für die Darstellung anderer Daten verwendet\footnote{vgl. hierzu: Webentwicklung mit CakePHP, 2. Auflage, O'Reilly, Seite 7}. CakePHP View Template Dateien Enden auf '.ctp' und bedienen sich der alternativen PHP Syntax für Kontrollstrukturen und Ausgabe. 
	In einer View kann direkt auf Variablen zugegriffen werden die in der entsprechenden Controller Methode gesetzt wurden:\\ 
   \lstset{language=PHP} 
	\begin{lstlisting}
	$this->set('articleCategories',  $articleCategories);
	\end{lstlisting}
	  Die Codebeispiele zeigen, wie die Variable \texttt{\$articleCategories} im Controller für die View freigegeben wird und dort z.B. mit einer foreach-Schleife durchlaufen werden kann um ihren Inhalt auszugeben. 
		\lstset{language=PHP}
		\begin{lstlisting}[caption={Alternative PHP Syntax}] 	
		<ul>
	   	<?php foreach ($todo as $item): ?>
		  <li><?= $item ?></li>
		<?php endforeach; ?>
		</ul>
		\end{lstlisting}
	 Eine View ist dabei nicht auf das Anzeigen von HTML Inhalten beschränkt, sondern kann auch dazu verwandt werden XML- oder JSON- Repräsentationen der angefragten Daten zurückzuliefern.
	\subsubsection{Controller}
	Der Controller regelt den Ablauf der Benutzerinteraktion.
	Er ist dafür zuständig, dass das richtige Model aufgerufen und die entsprechende Antwort oder View erzeugt wird. Er dient dabei als eine Art Vermittler zwischen dem Model und der View. Normalerweise ist in CakePHP ein Controller für ein Model verantwortlich, es ist dennoch möglich, oft auch nötig, dass ein Controller mit mehreren Models arbeitet.
	
	Der Controller enthält eine Reihe von  Methoden die HTTP Anfragen verarbeiten. Diese Methoden werden in CakePHP \textit{actions} genannt. Per Definition ist jede öffenliche Methode in einem Controller eine \textit{action} und über eine URL der Form \url{http://samplesite.com/article-categorie/view} erreichbar.
	Eine \textit{action} ist für die Verarbeitung der Anfrage und das zurückliefern einer Antwort zuständig. Im normalfall wird dabei eine View erzeugt, es können aber auch (wie im Abschnitt Model erläutert) auch XML oder JSON Daten zurückgeliefert werden.\footnote{vgl. hierzu: \url{http://book.cakephp.org/3.0/en/controllers.html}}
	
	\subsubsection{Component}
	Komponenten (Components) sind in sich geschlossene Bereiche innerhalb einer Applikation, die eine bestimmte Funktionalität kapseln und über die Grenzen eines Controllers hinaus verfügbar machen. Sollen bestimmte logische Prozesse in verschiedenen Teilen einer Anwendung zur Verfügung stehen - insbesondere in unterschiedlichen Controllern- so ist es sinnvoll diese in eine Komponente auszulagern.\footnote{vgl hierzu: CakeBuch Webentwcik, Seite 223}
	Die Möglichkeit mit Komponenten zu arbeiten setzt das DRY Paradigma konsequent um.
	
	\subsubsection{Shell}	
	CakePHP bietet die Möglichkeit Konsolenanwendungen zu schreiben. Dies ist nützlich für Anwendungen die per Cronjob ausgeführt werden sollen oder für solche die nicht aus einem Browser erreicht werden müssen bzw. sollen. \texttt{vgl. hierzu \url{http://book.cakephp.org/3.0/en/console-and-shells.html}}
	Eine der wichtigsten Funktionalität der Cake Shell ist das 'Backen' (Baking). Gemeint ist damit die automatische Generierung von Code. Der Befehl \texttt{bin/cake bake} erstellt, je nach gewählter Option, ganze MVC Grundgerüste, Controller- oder Model- Klassen, Plugin Verzeichnisstrukturen oder Shell-Klassen. Einzelne Funktionalitäten einer Shell Klasse können in Tasks ausgelagert werden.  
	
	\subsubsection{Einschätzung}
	
	
	
	\section{Analyse der Aufgabe und der Anforderungen}
	
	\subsection{Bewertung von theoretischen Ansätzen, Konzepten, Methoden, Verfahren}
		Im folgenden sollen die verwendeten Technologien bewertet werden. 
		Wie gut sind sie jeweils für den Einsatzzweck geeignet?
		Bewertungskriterien sind: 
		
		
	\subsubsection{CakePHP-Framework}
	
	
	
	\subsubsection{SQL Datenbank}
	
	
	\subsubsection{BMECat Format}
	
	Allgemeine Vorteile die sich aus dem XML-Format ergeben sind die gleichzeitige Mensch- und Maschinenlesbarkeit sowie die Möglichkeit das Dokument gegen ein XML-Schema testen zu können. So kann schon direkt nach der Erzeugung des BMECat Dokumentes überprüft werden, ob die geschriebenen Elemente vom richtigen Datentyp sind und das Dokument der in der XSD Datei festgelegten Struktur folgt. Weitere Vorteile speziell des BMECat Standards sind\footnote{vgl. hierzu: \url{http://wiki.prozeus.de/index.php/BMEcat}}:
	
	\begin{itemize}
	\item konfigurierbare Produkte sind abbildbar
	\item mehrsprachige Kataloge sind in einem Katalogdokument abbildbar
	\item Übermittlung multimedialer Datenelemente ist möglich (z.B. Produktvideos)	
	\item gilt zumindest in Deutschland als etabliertes Katalogaustauschformat	
	\end{itemize}
	
	
	
	\subsubsection{Datenübertragung zu Mercateo}
	
	Die Übertragung der Katalogdatei zum Mercateo-Server geschieht über FTP. Neue Dateien werden alle 30 Minuten vom Mercateo-System verarbeitet.\\
	\textbf{Vorteile:}
 	\begin{itemize}
   	\item einfach anzuwenden.
   	\item Eine korrekte Datenübertragung ist durch die Fehlerbehandlung von TCP gewährleistet.
   	\end{itemize}
	\textbf{Nachteile:}
   	\begin{itemize}
   	\item Datenübertragung nicht nach außen abgesichert.
   	\item Übertragene Daten können mitgelesen und manipuliert werden.
   	\item Benutzerkennung und Passwort können abgefangen werden
   	\end{itemize}
   	\textbf{Fazit:}\\
	Nicht optimal, vor allem aus Sicherheitsgründen. Zudem Fehleranfällig, wenn die Ordnerstruktur- und Dateinamenskonventionen von Mercateo nicht eingehalten werden \footnote{vgl. hierzu \url{http://www.mercateo.com/support/verkaufen/katalog-allgemeine-informationen/datenuebertragung-per-ftp/}}.

		
		
	\subsection{Funktionale und nichtfunktionale Anforderungen}	
			- 
	
	\subsection{Informelle Aufgabenbeschreibung}
	Ziel der Arbeit ist es die von der Software iTool aus verwaltbaren, in verschiedenen Tabellen einer SQL-Datenbank gehaltenen Produkt-, Katalog- Kategorie- und Herstellerdaten in ein von Mercateo verarbeitbares Format (dem BMECat) zu bringen. Dabei gilt es, den Anforderderungen der Spezifikationen sowohl das BMECat, als auch der besonderen Anforderungen seitens Mercateo zu genügen.
	Es soll möglich sein, die erwähnten Daten aus dem UI des iTool heraus nach dem CRUD-Prinzip zu bearbeiten. 
	Die eigentliche Erstellung der unterschiedlichen Kataloge (neuer Katalog bzw. Produktupdatekatalog) erfolgt dabei (automatisiert) über die CakePHP Shell. Kataloge können dabei für unterschiedliche Verkäufer erstellt werden.
	Zudem soll es Meracteo ermöglicht werden Bestandsdaten zu einer bestimmten Artikelnummer über ein Webinterface abzurufen.
	
	\subsection{Zielstellung}
	
	Folgende Funktionalitäten sollen implementiert werden:
	
	\begin{itemize}
	\item Die in iTool hinterlegten Produkt- bzw. Herstellerdaten sollen in ein gültiges und vollständiges BMECat Dokument entsprechend der Mercateo Anfoderungen überführt werden. Dabei ist insbesondere auf die Unterschiede und Besonderheiten der notwendigen beiden Transaktionsarten \texttt{T\_NEW\_CATALOG} - also die Erstellung eines neuen Kataloges - und \texttt{T\_UPDATE\_PRODUCTS} - also der Änderungen von Produktdaten, sowie dem löschen und neu erstellen von Produkten - zu achten .
		\begin{itemize}
		\item Gültig bedeutet in diesem Fall, dass Struktur und Inhalt des Dokuments fehlerfrei gegen die entsprechende XSD Datei laufen, d.h. die Felder müssen in der richtigen Reihenfolge unter Beachtung der Datentypen und Längenbegrenzungen sowie Formatlimitierungen (z.B. keine Sonderzeichen in der SKU (o.ä.)) geschrieben werden.
		\item Vollständig heißt, dass zum einen mindestens jene Felder im BMECat Dokument vorkommen, die die BMECat Spezifikation verlangt.Zusätzlich müssen jene Felder vorkommen, die die Mercateo Spezifikation erfordert und zwar unter zusätzlicher Beachtung der Limitierungen bzw. Besonderheiten jener Spezifikation. 	
		\end{itemize}
		
	\item Die Produktkategoriestruktur des iTool soll in das Kataloggruppensystem des BMECat überführt werden.
	\item die Implementierung der Katalogerstellungslogik erfolgt in einer Cake Shell. Liegt noch kein Katalog vor, wird ein neuer Katalog erstellt; ein Updatekatalog wird erstellt, wenn es Änderungen bei den Produktdaten gab. 
	\item Kataloge können für unterschiedliche Verkäufer erstellt werden.
	\item Die Produkt und Katalogdaten können über die Benutzeroberfläche des iTool eingesehen bzw. verändert werden. 
	\item Es soll Mercateo ermöglicht werden Bestandsdaten zu den im Katalog vermerkten Produkten über ein Webinterface abzurufen.
	\item Bei der Katalogerstellung ist darauf zu achten, dass es zu keinen Arbeitsspeicherüberläufen kommen kann.
	\end{itemize}
	
	\section{Entwurf}

	Die Erstellung der BMECat Dokumente wird über eine CakePHP Shell realisiert. Das hat den Vorteil, dass die Erstellung per CronJob gesteuert werden kann. Um die Shell im Bedarfsfall leicht erweitern zu können und nicht zu überladen wird die Logik in einen Shell-Task \texttt{prepareCatalog} ausgelagert. Bei Aufruf des Tasks wird die ID des Core-Sellers übergeben. So ist gewährleistet, dass nur die Produkte dieses Verkäufers exportiert werden. Die Spezifikation des BMECat verlangt, dass im Katalogdokument bestimmte Informationen zur Katalogversion, dem Katalognamen, der Währung \textit{etc.} aufgeführt werden. Diese Daten werden in einer Tabelle \texttt{mercateo\_accounts} gespeichert und können über die GUI des iTool eingesehen, erstellt, gelöscht und geändert werden. 
	
	Die Funktionen zum schreiben der einzelnen BMECat Abschnitte (\texttt{HEADER,T\_NEW\_CATALOG, CATALOG\_GROUP\_SYSTEM, ARTICLE, ARTICLE\_TO\_CATALOG\_GROUP\_MAP}) sind, aus Gründen der Übersicht und der Wiederverwendbarkeit in ein Component ausgelagert.
	
	Soll ein neues BMECat Dokument erstellt werden wird der Shell Task mit dem Befehl \texttt{bin/cake bme\_cat\_creator prepareCatalog 5} aufgerufen. Die dem Befehl nachgestellte Zahl dient als Aufrufparameter und repräsentiert die \textit{id} des Core-Sellers, dessen Produkte exportiert werden.
	
	 
	
	
	
	
	\subsection{XML schreiben}
		
	Um mit PHP XML schreiben zu können gibt es verschiedene, mehr oder weniger umfangreiche Klassen die hier kurz vorgestellt und eingeschätzt werden.
	Die zu erfüllenden Anforderungen sind:
	\begin{itemize}
	\item Elemente, Kindelemente und Attribute können geschrieben werden
	\item XML Datei kann gespeichert werden
	\item XML Datei kann gegen ein XSD Schema validiert werden.
	\end{itemize}
	
	\subsubsection{SimpleXML}
	
	SimpleXML ist eine sehr kompakte Klasse zum Lesen und Schreiben von XML Elementen und Attributen. Bietet die Möglichkeit generiertes XML in eine Datei zu schreiben.
	Eine Validierung ist nicht möglich.
	
	\subsubsection{DOMDocument}

	Die DOMDocument Klasse bietet sehr umfangreiche Möglichkeiten XML und HTML Dateien zu lesen, zu schreiben und zu bearbeiten. Elemente können über ihre \textit{id} oder \textit{tag} angesprochen werden. XML Dateien können geschrieben und validiert werden.
	
	\subsubsection{XMLWriter}
	Die XML Writer Klasse bietet, ihrem Namen entsprechend, die Möglichkeit XML zu schreiben und ist ein Wrapper für den in C geschriebenen libxml XML Parser.
	Ok....blablabla---Valeri Fragen warum er das verwendet hat....
	Die XMLWriter Klasse bietet die Möglichkeit, XML Dateien zu schreiben. XML kann nicht validiert werden.
	
	Um XML zu schreiben wird ein bereits vorhandener, komfortabel und einfach zu nutzender, CakePHP Component (\texttt{XMLWriterComponent}) verwendet, der die Funktionalitäten der PHP XMLWriter Klasse benutzt. Um das XML Dokument zu validieren kann die \texttt{XMLReaderComponetn}-Klasse verwendet werden.
	
	\subsection{Erstellung eines neuen BMECat Dokumentes}
	
	\section{Implementierung}
	
	Hier kommt die Umsetzung des Ganzen rein, also der tatsächliche Programmablauf
	
	\section{Test}

	Hier kann vielleicht auch die Validation rein (MercateoAccountsTable)
	

